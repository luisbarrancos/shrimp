<shrimp name="new_scene">
	<about/>
	<network>
		<block id="Bake" position_x="4" position_y="-1" author="rconstruct">
			<input name="bakefile" type="string" storage="uniform" shader_parameter="1" value="&quot;/tmp/testbake.bake&quot;" description="Baked map filename"/>
			<input name="ss" type="float" storage="varying" value="s" description="X coordinate">
				<connection parent="st" output="s"/>
			</input>
			<input name="tt" type="float" storage="varying" value="t" description="Y coordinate">
				<connection parent="st" output="t"/>
			</input>
			<input name="bdata" type="color" storage="varying" value="0" description="Data to bake" type_parent="bdataout">
				<connection parent="Multiply_2" output="val"/>
			</input>
			<input name="ascii" type="float" storage="varying" value="1" description="ASCII/binary file toggle"/>
			<output name="bdataout" type="color" storage="varying" description="Baked data"/>
			<code>
	#if RENDERER==aqsis
		bake( $(bakefile), $(ss), $(tt), $(bdata) );
		$(bdataout) = $(bdata);
		
	#elif RENDERER==_3delight
	
	/* default is to save in ASCII format */
	#define bakeformat_$(ascii)
	#ifdef bakeformat_1
		bake( $(bakefile), $(ss), $(tt), $(bdata) );
		$(bdataout) = $(bdata);
	#else
		bake( concat( $(bakefile), &quot;binary&quot;), $(ss), $(tt), $(bdata) );
		$(bdataout) = $(bdata);
	#endif
		
	#else
	/* bake() is only supported on Aqsis and 3delight apparently */
		$(bdataout) = $(bdata);
	#endif
			
							</code>
			<include/>
			<usage>Bakes the supplied data channel into a bakefile. Note that this shadeop is only supported in Aqsis and 3Delight; you can use bake3d in other implementations. In 3Delight&apos;s case, you can force the baked file to be in binary format, instead of ASCII format, by toggling the ascii parameter, which is enabled (ascii on) by default.						</usage>
		</block>
		<block id="Diffuse" position_x="-1" position_y="1.63076923076923" author="rconstruct">
			<input name="norm" type="normal" storage="varying" value="normalize(N)" description="The surface normal"/>
			<output name="col" type="color" storage="varying" description="The amount of diffuse light"/>
			<code>
	$(col) = diffuse( $(norm) );
							</code>
			<include/>
			<usage>Lambertian Diffuse term. This is meant to be combined in your network, with an diffuse, and/or specular term, as needed. Cs isn&apos;t taken into consideration here, nor is Os, you must include this in your network (multiply ambient and diffuse by your Cs, as for Os, use the output node opacity entry).						</usage>
		</block>
		<block id="Multiply" position_x="-4" position_y="-1" author="rconstruct">
			<input name="A" type="point" storage="varying" value="1" description="1st input" type_parent="val">
				<connection parent="Transform" output="pp"/>
			</input>
			<input name="B" type="point" storage="varying" multi="*" value="1" description="2nd or subsequent inputs" type_parent="val"/>
			<output name="val" type="point" storage="varying" description="val = A * B"/>
			<code>
	$(val) = $(A) * $(B);
							</code>
			<include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.
							</usage>
		</block>
		<block id="Multiply_2" position_x="1" position_y="1" author="rconstruct">
			<input name="A" type="color" storage="varying" value="1" description="1st input" type_parent="val">
				<connection parent="Diffuse" output="col"/>
			</input>
			<input name="B" type="color" storage="varying" multi="*" value="1" description="2nd or subsequent inputs" type_parent="val">
				<connection parent="Turbulence3D" output="val"/>
			</input>
			<output name="val" type="color" storage="varying" description="val = A * B"/>
			<code>
	$(val) = $(A) * $(B);
							</code>
			<include/>
			<usage>All inputs must be of the same type. The operation is done in parallel for each component.
							</usage>
		</block>
		<block id="Root block" position_x="6" position_y="1" author="" root="RIB" AOV_preview="1">
			<rib_statements>Attribute &quot;cull&quot; &quot;integer hidden&quot; 0
Attribute &quot;cull&quot; &quot;integer backfacing&quot; 0
Attribute &quot;sides&quot; &quot;integer doubleshaded&quot; 0
			</rib_statements>
			<imager_statement/>
			<input name="Ci" type="color" storage="varying" shader_parameter="1" value="0" description="Incident ray colour">
				<connection parent="Bake" output="bdataout"/>
			</input>
			<input name="Oi" type="color" storage="varying" shader_parameter="1" value="1" description="Incident ray opacity"/>
			<input name="P" type="point" storage="varying" shader_parameter="1" value="P" description="Displaced surface position"/>
			<input name="N" type="normal" storage="varying" shader_parameter="1" value="N" description="Displaced surface shading normal"/>
			<input name="Cl" type="color" storage="varying" shader_parameter="1" value="0" description="Outgoing light ray colour"/>
			<input name="Ol" type="color" storage="varying" shader_parameter="1" value="1" description="Outgoing light ray opacity"/>
			<input name="Cv" type="color" storage="varying" shader_parameter="1" value="0" description="Attenuated ray colour"/>
			<input name="Ov" type="color" storage="varying" shader_parameter="1" value="1" description="Attenuated ray opacity"/>
			<input name="Cm" type="color" storage="varying" shader_parameter="1" value="0" description="Output pixel colour"/>
			<input name="Om" type="color" storage="varying" shader_parameter="1" value="1" description="Output pixel opacity"/>
			<input name="AOV" type="color" storage="varying" shader_parameter="1" value="1" description="AOV preview output"/>
			<code/>
			<include/>
			<usage/>
		</block>
		<block id="Transform" position_x="-4" position_y="1" author="rconstruct">
			<input name="p" type="point" storage="varying" value="P" description="Point, vector or normal to transform" type_parent="pp">
				<connection parent="p" output="P"/>
			</input>
			<input name="from_space" type="string" storage="uniform" value="&quot;current&quot;" description="The coordinate system to transform from"/>
			<input name="to_space" type="string" storage="uniform" value="&quot;object&quot;" description="The coordinate system to transform into"/>
			<input name="mmat" type="matrix" storage="varying" value="none" description="Use this matrix instead of a predefined coordinate system"/>
			<output name="pp" type="point" storage="varying" description="The transformed point, vector or normal"/>
			<code>
	#define $(p)_$(p:type)
	#define mmat_$(mmat)
	#ifdef $(p)_point
	#ifdef mmat_none
		$(pp) = transform( $(from_space), $(to_space), $(p) );
	#else
		$(pp) = transform( $(from_space), $(mmat), $(p) );
	#endif
	#elif $(p)_vector
	#ifdef mmat_none
		$(pp) = vtransform( $(from_space), $(to_space), $(p) );
	#else
		$(pp) = vtransform( $(from_space), $(mmat), $(p) );
	#endif
	#else
	#ifdef mmat_none
		$(pp) = ntransform( $(from_space), $(to_space), $(p) );
	#else
		$(pp) = ntransform( $(from_space), $(mmat), $(p) );
	#endif
	#endif
							</code>
			<include/>
			<usage>The transform function transforms the point P (or vector V, or normal N, invoking vtransform and ntransform accordingly), from the coordinate system fromspace to the cordinate system tospace.. If fromspace isn&apos;t passed, then it assumes it to be the current coordinate system. Coordinate systems are, raster, screen, camera, world, and object. A shader knows also, the shader (the object coordinate system when the object was defined), current (world or camera), and custom coordinate systems. A transformation matrix might be given as a destination coordinate system.						</usage>
		</block>
		<block id="Turbulence3D" position_x="-2" position_y="0" author="rconstruct">
			<input name="p" type="point" storage="varying" value="P" description="point to sample turbulence at">
				<connection parent="Multiply" output="val"/>
			</input>
			<input name="fwidth" type="float" storage="varying" value="0" description="Filter width for antialiasing"/>
			<input name="octaves" type="float" storage="varying" value="5" description="Maximum octaves of noise"/>
			<input name="lacunarity" type="float" storage="varying" value="2.17" description="Controls the smoothness of the turbulence"/>
			<input name="gain" type="float" storage="varying" value="0.5" description="Controls the contrast of the turbulence"/>
			<input name="amplitude" type="float" storage="varying" value="1" description="Amplitude of turbulence"/>
			<output name="val" type="color" storage="varying" description="turbulence value at p"/>
			<code>
	#define $(val)_$(val:type)
	#ifdef $(val)_float
		$(val) = $(amplitude) * turbulence( $(p), $(fwidth), $(octaves),
					$(lacunarity), $(gain) );
	#else
		$(val) = $(amplitude) * $(val:type) ( vector vturbulence( $(p),
					$(fwidth), $(octaves), $(lacunarity), $(gain) ) );
	#endif
							</code>
			<include>fractal.h						</include>
			<usage>This is the Perlin turbulence function.
							</usage>
		</block>
		<block id="p" position_x="-4" position_y="2" author="rconstruct">
			<output name="P" type="point" storage="varying" description="Surface position"/>
			<code>
    $(P) = P;
    						</code>
			<include/>
			<usage>Note that in all shaders types, P is the surface position, the only exception being volume shaders, in which P is the light ray origin. Also note that in imager shaders, P is the position of the pixel center in raster space, with the z coordinate being 0.						</usage>
		</block>
		<block id="st" position_x="2" position_y="-2" author="rconstruct">
			<output name="s" type="float" storage="varying" description="S texture coordinate"/>
			<output name="t" type="float" storage="varying" description="T texture coordinate"/>
			<code>
    $(s) = s;
    $(t) = t;
    						</code>
			<include/>
			<usage/>
		</block>
	</network>
</shrimp>
